<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>å¯¸æ³•æ¸¬å®šæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ - CarScan Pro</title>
    <style>
        /* Tailwind-like styles inline */
        * { box-sizing: border-box; }
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background-color: #f3f4f6; 
            line-height: 1.5;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 2rem 1rem; 
        }
        .bg-white { background-color: white; }
        .rounded-lg { border-radius: 0.5rem; }
        .shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .p-6 { padding: 1.5rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mt-6 { margin-top: 1.5rem; }
        .mr-4 { margin-right: 1rem; }
        .text-3xl { font-size: 1.875rem; }
        .text-xl { font-size: 1.25rem; }
        .text-lg { font-size: 1.125rem; }
        .text-sm { font-size: 0.875rem; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .font-medium { font-weight: 500; }
        .text-gray-800 { color: #1f2937; }
        .text-gray-700 { color: #374151; }
        .text-gray-600 { color: #4b5563; }
        .text-gray-500 { color: #6b7280; }
        .text-blue-600 { color: #2563eb; }
        .text-yellow-800 { color: #92400e; }
        .text-red-600 { color: #dc2626; }
        .text-green-600 { color: #059669; }
        .bg-gray-100 { background-color: #f3f4f6; }
        .bg-gray-50 { background-color: #f9fafb; }
        .bg-gray-900 { background-color: #111827; }
        .bg-blue-50 { background-color: #eff6ff; }
        .bg-yellow-50 { background-color: #fffbeb; }
        .w-full { width: 100%; }
        .max-w-2xl { max-width: 42rem; }
        .h-auto { height: auto; }
        .block { display: block; }
        .hidden { display: none !important; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .space-x-4 > * + * { margin-left: 1rem; }
        .space-y-1 > * + * { margin-top: 0.25rem; }
        .grid { display: grid; }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .gap-4 { gap: 1rem; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .overflow-hidden { overflow: hidden; }
        .overflow-y-auto { overflow-y: auto; }
        .max-h-40 { max-height: 10rem; }
        .object-contain { object-fit: contain; }
        .border { border-width: 1px; }
        .border-gray-300 { border-color: #d1d5db; }
        .border-yellow-200 { border-color: #fde68a; }
        .rounded-md { border-radius: 0.375rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .py-8 { padding-top: 2rem; padding-bottom: 2rem; }
        
        /* Button styles */
        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-decoration: none;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .bg-blue-500 { background-color: #3b82f6; color: white; }
        .bg-blue-500:hover:not(:disabled) { background-color: #2563eb; }
        .bg-green-500 { background-color: #10b981; color: white; }
        .bg-green-500:hover:not(:disabled) { background-color: #059669; }
        .bg-gray-500 { background-color: #6b7280; color: white; }
        .bg-gray-500:hover:not(:disabled) { background-color: #4b5563; }
        
        /* File input styles */
        input[type="file"] {
            display: block;
            width: 100%;
            padding: 0.5rem;
            border: 2px dashed #d1d5db;
            border-radius: 0.5rem;
            background-color: #f9fafb;
            cursor: pointer;
        }
        input[type="file"]:hover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        
        /* Video and canvas styles */
        video, canvas {
            border-radius: 0.5rem;
            background-color: #000;
        }
        
        /* Input styles */
        input[type="number"] {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="bg-white rounded-lg shadow-md p-6">
            <h1 class="text-3xl font-bold text-gray-800 mb-6">å¯¸æ³•æ¸¬å®šæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h1>
              <!-- å‹•ç”»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ -->
            <div class="mb-6">
                <input type="file" id="videoUpload" accept="video/*" class="mb-4">
                <video id="videoPlayer" class="w-full max-w-2xl h-auto" controls style="display:none; background-color: black; border-radius: 0.5rem;"></video>
            </div><!-- ãƒœã‚¿ãƒ³ -->
            <div class="mb-6">
                <button id="captureFrameButton" class="btn bg-blue-500 mr-4" disabled>ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£</button>
                <button id="startMeasurementButton" class="btn bg-green-500 mr-4" disabled>æ¸¬å®šé–‹å§‹</button>
                <button id="resetCaptureButton" class="btn bg-gray-500" disabled>ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒªã‚»ãƒƒãƒˆ</button>
            </div><!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ -->
            <div class="relative bg-gray-900 rounded-lg overflow-hidden mb-6" style="height: 600px;">
                <canvas id="videoCanvas" class="absolute inset-0 w-full h-full object-contain" style="display: none;"></canvas>
            </div>

            <!-- ã‚­ãƒ£ãƒ—ãƒãƒ£ç”»åƒå°‚ç”¨ã‚¨ãƒªã‚¢ -->
            <div id="captureImageArea" class="relative bg-gray-900 rounded-lg overflow-hidden mb-6 hidden" style="height: 600px;">
                <canvas id="captureCanvas" class="absolute inset-0 w-full h-full object-contain"></canvas>
            </div>            <!-- ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
            <div id="zoomControlsContainer" class="flex items-center space-x-4 mb-6 hidden">
                <button id="zoomInButton" class="btn bg-blue-500">ã‚ºãƒ¼ãƒ +</button>
                <button id="zoomOutButton" class="btn bg-blue-500">ã‚ºãƒ¼ãƒ -</button>
                <button id="zoomResetButton" class="btn bg-gray-500">ãƒªã‚»ãƒƒãƒˆ</button>
                <span class="text-sm text-gray-600">ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•</span>
            </div>            <!-- ã‚­ãƒ£ãƒ—ãƒãƒ£å°‚ç”¨ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
            <div id="captureZoomControlsContainer" class="flex items-center space-x-4 mb-6 hidden">
                <button id="captureZoomInButton" class="btn bg-blue-500">ã‚ºãƒ¼ãƒ +</button>
                <button id="captureZoomOutButton" class="btn bg-blue-500">ã‚ºãƒ¼ãƒ -</button>
                <button id="captureZoomResetButton" class="btn bg-gray-500">ãƒªã‚»ãƒƒãƒˆ</button>
                <span class="text-sm text-gray-600">å°‚ç”¨ã‚¨ãƒªã‚¢ - ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã€å·¦ã‚¯ãƒªãƒƒã‚¯+ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€æ¸¬å®šé–‹å§‹å¾Œã«å·¦ã‚¯ãƒªãƒƒã‚¯ã§æ¸¬å®šç‚¹ã‚’é…ç½®</span>
            </div>

            <!-- å¯¸æ³•æ¸¬å®šå…¥åŠ› -->
            <div id="dimensionMeasurementInputs" class="bg-gray-50 p-4 rounded-lg mb-6 hidden">
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿéš›ã®ã‚µã‚¤ã‚º (mm)</label>
                    <input type="number" id="refObjectActualSizeInput" class="w-full px-3 py-2 border border-gray-300 rounded-md" placeholder="ä¾‹: 1800 (è»Šã®å¹…)">
                </div>
            </div>

            <!-- çµæœè¡¨ç¤º -->
            <div id="resultsArea" class="hidden">
                <div id="dimensionResultsDisplay" class="bg-blue-50 p-4 rounded-lg">
                    <h2 class="text-xl font-semibold text-gray-700 mb-3">å¯¸æ³•æ¸¬å®šçµæœ:</h2>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <p class="text-sm text-gray-600">å‚ç…§ç·šãƒ”ã‚¯ã‚»ãƒ«é•·:</p>
                            <p class="text-lg font-semibold" id="refPixelLengthText">-</p>
                        </div>
                        <div>
                            <p class="text-sm text-gray-600">ã‚¹ã‚±ãƒ¼ãƒ« (mm/pixel):</p>
                            <p class="text-lg font-semibold" id="scaleText">-</p>
                        </div>
                        <div>
                            <p class="text-sm text-gray-600">å¯¾è±¡ç·šãƒ”ã‚¯ã‚»ãƒ«é•·:</p>
                            <p class="text-lg font-semibold" id="targetPixelLengthText">-</p>
                        </div>
                        <div>
                            <p class="text-sm text-gray-600">æ¨å®šã‚µã‚¤ã‚º (mm):</p>
                            <p class="text-lg font-semibold text-blue-600" id="estimatedSizeText">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º -->
            <div class="mt-6 p-4 bg-gray-50 rounded-lg">
                <p id="commonInstructionText" class="text-sm text-gray-600 mb-2">å‹•ç”»ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦å¯¸æ³•æ¸¬å®šã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>
                <p id="dimensionStatusText" class="text-sm font-medium text-blue-600">å¾…æ©Ÿä¸­</p>
            </div>            <!-- ãƒ‡ãƒãƒƒã‚°æƒ…å ± -->
            <div class="mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <h3 class="text-lg font-semibold text-yellow-800 mb-2">ãƒ‡ãƒãƒƒã‚°æƒ…å ±</h3>
                <div class="grid grid-cols-3 gap-4 text-sm">
                    <div>
                        <p>ãƒã‚¦ã‚¹åº§æ¨™: <span id="debugMousePos">-</span></p>
                        <p>å¤‰æ›å¾Œåº§æ¨™: <span id="debugTransformTest">-</span></p>
                        <p>æœ€å¾Œã®ã‚¯ãƒªãƒƒã‚¯: <span id="debugLastClick">-</span></p>
                    </div>
                    <div>
                        <p>ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«: <span id="debugZoomLevel">1.0</span></p>
                        <p>ã‚ªãƒ•ã‚»ãƒƒãƒˆ: <span id="debugOffset">0, 0</span></p>
                        <p>æ¸¬å®šçŠ¶æ…‹: <span id="debugMeasurementState">idle</span></p>
                    </div>
                    <div>
                        <p>ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚ºãƒ¼ãƒ : <span id="debugZoom">1.0</span></p>
                        <p>ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚ªãƒ•ã‚»ãƒƒãƒˆ: <span id="debugOffsetX">0</span>, <span id="debugOffsetY">0</span></p>
                        <p>ç”»åƒã‚µã‚¤ã‚º: <span id="debugImageSize">-</span></p>
                        <p>ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º: <span id="debugCanvasSize">-</span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden containers for compatibility -->
    <div id="sharedControlsContainer" class="hidden"></div>
    <div id="oncomingAnalysisResultsDisplay" class="hidden"></div>
    <div id="aiCommentSection" class="hidden">
        <input id="targetObjectNameInput" type="text">
        <button id="getAiCommentButton"></button>
        <div id="aiCommentText"></div>
    </div>    <!-- JavaScript ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« -->
    <!-- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ESã‚¨ãƒ©ãƒ¼ã®ãŸã‚ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–ã€ç›´æ¥å®Ÿè£…ã«åˆ‡ã‚Šæ›¿ãˆ -->
    <!-- <script src="js/utils/math.js"></script>
    <script src="js/utils/canvas.js"></script>
    <script src="js/components/capture-zoom-pan.js"></script>
    <script src="js/components/capture-marking.js"></script>
    <script src="js/analysis/dimension.js"></script> -->
    
    <script>
        // DOMè¦ç´ ã®å–å¾—
        const videoUpload = document.getElementById('videoUpload');
        const videoPlayer = document.getElementById('videoPlayer');
        // const videoCanvas = document.getElementById('videoCanvas'); // Not directly used for dimension measurement display
        const captureImageArea = document.getElementById('captureImageArea');
        const captureCanvas = document.getElementById('captureCanvas');
        const captureFrameButton = document.getElementById('captureFrameButton');
        const startMeasurementButton = document.getElementById('startMeasurementButton');
        const resetCaptureButton = document.getElementById('resetCaptureButton');
        const captureZoomControlsContainer = document.getElementById('captureZoomControlsContainer');
        const dimensionMeasurementInputs = document.getElementById('dimensionMeasurementInputs');
        const resultsArea = document.getElementById('resultsArea');
        const dimensionResultsDisplay = document.getElementById('dimensionResultsDisplay');
        const refObjectActualSizeInput = document.getElementById('refObjectActualSizeInput');
        const refPixelLengthText = document.getElementById('refPixelLengthText');
        const scaleText = document.getElementById('scaleText');
        const targetPixelLengthText = document.getElementById('targetPixelLengthText');
        const estimatedSizeText = document.getElementById('estimatedSizeText');
        const commonInstructionText = document.getElementById('commonInstructionText');
        const dimensionStatusText = document.getElementById('dimensionStatusText');
        
        // é‡è¦ãªè¦ç´ ã®å­˜åœ¨ç¢ºèª
        const requiredElements = [
            { name: 'videoUpload', element: videoUpload },
            { name: 'videoPlayer', element: videoPlayer },
            { name: 'captureCanvas', element: captureCanvas },
            { name: 'captureFrameButton', element: captureFrameButton },
            { name: 'dimensionStatusText', element: dimensionStatusText }
        ];
          const missingElements = requiredElements.filter(req => !req.element);
        if (missingElements.length > 0) {
            console.error("âŒ Missing required DOM elements:", missingElements.map(req => req.name));
            const errorMsg = "å¿…è¦ãªDOMè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " + missingElements.map(req => req.name).join(', ');
            alert(errorMsg);
            throw new Error(errorMsg); // returnã®ä»£ã‚ã‚Šã«throwã‚’ä½¿ç”¨
        } else {
            console.log("âœ… All required DOM elements found");
        }
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
        // const visibleCtx = videoCanvas.getContext('2d'); // Not directly used
        const captureCtx = captureCanvas.getContext('2d'); // Used by capture-zoom-pan and capture-marking
        
        // å¤‰æ•°åˆæœŸåŒ–
        let currentAppMode = 'none';
        let measurementState = 'idle'; // More detailed states will be managed within dimension.js or here
        let points = []; // General points, might be managed by dimension.js
        let pointsForRefLine = []; // Specific for test page logic if not fully in dimension.js
        let pointsForTargetLine = []; // Specific for test page logic
        let refPixelLength = 0;
        let scale = 0;
        let currentEstimatedSizeMm = 0;
        // zoomLevel, viewOffsetX, viewOffsetY are for the main video, not used in capture mode
        let videoNaturalWidth = 0;
        let videoNaturalHeight = 0;        // sourceFrameCanvas can be managed by dimension.js or passed to it.
        // let sourceFrameCanvas = document.createElement('canvas'); 
        // let sourceFrameCtx = sourceFrameCanvas.getContext('2d');
        
        // ã‚­ãƒ£ãƒ—ãƒãƒ£æ©Ÿèƒ½ç”¨å¤‰æ•° (ç›´æ¥å®Ÿè£…)
        let captureZoomLevel = 1.0;
        let captureViewOffsetX = 0;
        let captureViewOffsetY = 0;
        let captureImageWidth = 0;
        let captureImageHeight = 0;
        let captureIsPanning = false;
        let captureLastMouseX = 0;
        let captureLastMouseY = 0;
        let capturedImageElement = null; // ã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚ŒãŸç”»åƒãƒ‡ãƒ¼ã‚¿

        // æ¸¬å®šæ©Ÿèƒ½ç”¨å¤‰æ•°
        let measurementMode = 'none'; // 'none', 'reference', 'target'
        let measurementPoints = []; // æ¸¬å®šç‚¹ã®é…åˆ—
        let referencePoints = []; // å‚ç…§ç·šã®2ç‚¹
        let targetPoints = []; // æ¸¬å®šå¯¾è±¡ç·šã®2ç‚¹
        let isDrawingLine = false; // ç·šã‚’æç”»ä¸­ã‹ã©ã†ã‹

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚­ãƒ£ãƒ—ãƒãƒ£ç”»åƒè¦ç´ 
        if (!window.capturedImageElement) {
            window.capturedImageElement = new Image();
        }

        // åº§æ¨™å¤‰æ›æ©Ÿèƒ½
        function canvasToImageCoords(canvasX, canvasY) {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã‚’å…ƒç”»åƒåº§æ¨™ã«å¤‰æ›
            const imageX = (canvasX - captureViewOffsetX) / captureZoomLevel;
            const imageY = (canvasY - captureViewOffsetY) / captureZoomLevel;
            return { x: imageX, y: imageY };
        }

        function imageToCanvasCoords(imageX, imageY) {
            // å…ƒç”»åƒåº§æ¨™ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«å¤‰æ›
            const canvasX = imageX * captureZoomLevel + captureViewOffsetX;
            const canvasY = imageY * captureZoomLevel + captureViewOffsetY;
            return { x: canvasX, y: canvasY };
        }

        // è·é›¢è¨ˆç®—
        function calculateDistance(point1, point2) {
            const dx = point2.x - point1.x;
            const dy = point2.y - point1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ©Ÿèƒ½ã®å®Ÿè£…
        function initCaptureZoomPan() {
            const canvas = captureCanvas;
            if (!canvas) return;

            // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const oldZoom = captureZoomLevel;
                captureZoomLevel = Math.max(0.1, Math.min(10, captureZoomLevel * zoomFactor));
                
                // ã‚ºãƒ¼ãƒ ä¸­å¿ƒã‚’ãƒã‚¦ã‚¹ä½ç½®ã«åˆã‚ã›ã‚‹
                const zoomRatio = captureZoomLevel / oldZoom;
                captureViewOffsetX = mouseX - (mouseX - captureViewOffsetX) * zoomRatio;
                captureViewOffsetY = mouseY - (mouseY - captureViewOffsetY) * zoomRatio;
                  redrawCaptureCanvas();
                updateCaptureDebugInfo();
            });
            
            // å·¦ã‚¯ãƒªãƒƒã‚¯+ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³ã€æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚¯ãƒªãƒƒã‚¯ã§ç‚¹é…ç½®
            let clickStartTime = 0;
            let clickStartX = 0;
            let clickStartY = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // å·¦ã‚¯ãƒªãƒƒã‚¯
                    e.preventDefault();
                    clickStartTime = Date.now();
                    clickStartX = e.clientX;
                    clickStartY = e.clientY;
                    
                    if (measurementMode === 'none') {
                        // ãƒ‘ãƒ³ãƒ¢ãƒ¼ãƒ‰
                        captureIsPanning = true;
                        captureLastMouseX = e.clientX;
                        captureLastMouseY = e.clientY;
                        canvas.style.cursor = 'grabbing';
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (captureIsPanning && measurementMode === 'none') {
                    const deltaX = e.clientX - captureLastMouseX;
                    const deltaY = e.clientY - captureLastMouseY;
                    
                    captureViewOffsetX += deltaX;
                    captureViewOffsetY += deltaY;
                    
                    captureLastMouseX = e.clientX;
                    captureLastMouseY = e.clientY;
                    
                    redrawCaptureCanvas();
                    updateCaptureDebugInfo();
                } else if (measurementMode === 'none') {
                    // ãƒ›ãƒãƒ¼æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤º
                    canvas.style.cursor = 'grab';
                } else {
                    // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰æ™‚ã¯ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ã‚«ãƒ¼ã‚½ãƒ«
                    canvas.style.cursor = 'crosshair';
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    const clickDuration = Date.now() - clickStartTime;
                    const clickDistance = Math.sqrt(
                        (e.clientX - clickStartX) ** 2 + (e.clientY - clickStartY) ** 2
                    );
                    
                    // ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šï¼ˆçŸ­æ™‚é–“ã‹ã¤ç§»å‹•è·é›¢ãŒå°ã•ã„ï¼‰
                    if (clickDuration < 200 && clickDistance < 5) {
                        if (measurementMode !== 'none') {
                            handleMeasurementClick(e);
                        }
                    }
                    
                    if (captureIsPanning) {
                        captureIsPanning = false;
                        canvas.style.cursor = measurementMode === 'none' ? 'grab' : 'crosshair';
                    }
                }
            });            // ãƒã‚¦ã‚¹ãŒã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰é›¢ã‚ŒãŸæ™‚
            canvas.addEventListener('mouseleave', () => {
                canvas.style.cursor = 'default';
            });
            
            // å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç„¡åŠ¹åŒ–ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é˜²ããŸã‚ï¼‰
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            console.log("âœ… Capture zoom/pan initialized");
        }

        // æ¸¬å®šã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleMeasurementClick(e) {
            const rect = captureCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã‚’ç”»åƒåº§æ¨™ã«å¤‰æ›
            const imageCoords = canvasToImageCoords(canvasX, canvasY);
            
            // ç”»åƒç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
            if (imageCoords.x < 0 || imageCoords.x > captureImageWidth || 
                imageCoords.y < 0 || imageCoords.y > captureImageHeight) {
                console.log('ã‚¯ãƒªãƒƒã‚¯ä½ç½®ãŒç”»åƒç¯„å›²å¤–ã§ã™');
                return;
            }

            if (measurementMode === 'reference') {
                // å‚ç…§ç·šã®ç‚¹ã‚’è¿½åŠ 
                referencePoints.push(imageCoords);
                console.log(`å‚ç…§ç‚¹${referencePoints.length}ã‚’è¿½åŠ :`, imageCoords);
                
                if (referencePoints.length >= 2) {
                    const distance = calculateDistance(referencePoints[0], referencePoints[1]);
                    console.log(`å‚ç…§ç·šã®é•·ã•: ${distance.toFixed(2)} pixels`);
                    
                    // UIæ›´æ–°
                    document.getElementById('refPixelLengthText').textContent = distance.toFixed(2);
                    showUIMessage(dimensionStatusText, "å‚ç…§ç·šã‚’è¨­å®šã—ã¾ã—ãŸã€‚å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                    showUIMessage(commonInstructionText, "å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºï¼ˆmmï¼‰ã‚’å…¥åŠ›ã—ã€æ¬¡ã«æ¸¬å®šå¯¾è±¡ç·šã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚");
                    
                    // æ¸¬å®šå¯¾è±¡ç·šãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
                    measurementMode = 'target';
                    updateMeasurementModeUI();
                }
            } else if (measurementMode === 'target') {
                // æ¸¬å®šå¯¾è±¡ç·šã®ç‚¹ã‚’è¿½åŠ 
                targetPoints.push(imageCoords);
                console.log(`æ¸¬å®šç‚¹${targetPoints.length}ã‚’è¿½åŠ :`, imageCoords);
                
                if (targetPoints.length >= 2) {
                    const distance = calculateDistance(targetPoints[0], targetPoints[1]);
                    console.log(`æ¸¬å®šç·šã®é•·ã•: ${distance.toFixed(2)} pixels`);
                    
                    // å¯¸æ³•è¨ˆç®—ã‚’å®Ÿè¡Œ
                    calculateDimensions();
                    
                    // æ¸¬å®šå®Œäº†
                    measurementMode = 'completed';
                    updateMeasurementModeUI();
                }
            }

            redrawCaptureCanvas();
            updateCaptureDebugInfo();
        }

        // å¯¸æ³•è¨ˆç®—
        function calculateDimensions() {
            if (referencePoints.length < 2 || targetPoints.length < 2) return;

            const refPixelDistance = calculateDistance(referencePoints[0], referencePoints[1]);
            const targetPixelDistance = calculateDistance(targetPoints[0], targetPoints[1]);
            
            // å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’å–å¾—
            const refActualSize = parseFloat(document.getElementById('refObjectActualSizeInput').value);
            
            if (!refActualSize || refActualSize <= 0) {
                showUIMessage(dimensionStatusText, "å‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                return;
            }

            // ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—ï¼ˆmm/pixelï¼‰
            const scale = refActualSize / refPixelDistance;
            
            // æ¸¬å®šå¯¾è±¡ã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºè¨ˆç®—
            const estimatedSize = targetPixelDistance * scale;

            // çµæœã‚’UIã«è¡¨ç¤º
            document.getElementById('refPixelLengthText').textContent = refPixelDistance.toFixed(2);
            document.getElementById('targetPixelLengthText').textContent = targetPixelDistance.toFixed(2);
            document.getElementById('scaleText').textContent = scale.toFixed(4);
            document.getElementById('estimatedSizeText').textContent = estimatedSize.toFixed(2) + ' mm';

            console.log(`æ¸¬å®šçµæœ: ${estimatedSize.toFixed(2)} mm`);
            showUIMessage(dimensionStatusText, "æ¸¬å®šå®Œäº†ï¼");
            showUIMessage(commonInstructionText, `æ¸¬å®šçµæœ: ${estimatedSize.toFixed(2)} mm`);
        }

        // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰UIæ›´æ–°
        function updateMeasurementModeUI() {
            const statusText = document.getElementById('debugMeasurementState');
            if (statusText) {
                statusText.textContent = measurementMode;
            }

            // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            const startBtn = document.getElementById('startMeasurementButton');
            if (measurementMode === 'reference') {
                startBtn.textContent = 'å‚ç…§ç·šè¨­å®šä¸­...';
                startBtn.disabled = true;
            } else if (measurementMode === 'target') {
                startBtn.textContent = 'æ¸¬å®šç·šè¨­å®šä¸­...';
                startBtn.disabled = true;
            } else if (measurementMode === 'completed') {
                startBtn.textContent = 'æ¸¬å®šå®Œäº†';
                startBtn.disabled = false;
            } else {
                startBtn.textContent = 'æ¸¬å®šé–‹å§‹';
                startBtn.disabled = false;
            }
        }

        // ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚­ãƒ£ãƒ³ãƒã‚¹å†æç”»
        function redrawCaptureCanvas() {
            if (!captureCanvas || !capturedImageElement) return;
            
            const ctx = captureCanvas.getContext('2d');
            ctx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
            
            if (capturedImageElement && capturedImageElement.complete) {
                const drawWidth = captureImageWidth * captureZoomLevel;
                const drawHeight = captureImageHeight * captureZoomLevel;
                
                ctx.drawImage(
                    capturedImageElement,
                    captureViewOffsetX,
                    captureViewOffsetY,
                    drawWidth,
                    drawHeight
                );
            }

            // æ¸¬å®šç‚¹ã¨ç·šã‚’æç”»
            drawMeasurementElements(ctx);
        }

        // æ¸¬å®šè¦ç´ æç”»
        function drawMeasurementElements(ctx) {
            // å‚ç…§ç·šã‚’æç”»ï¼ˆèµ¤ï¼‰
            if (referencePoints.length >= 2) {
                drawLine(ctx, referencePoints[0], referencePoints[1], '#FF0000', 3, 'å‚ç…§ç·š');
            } else if (referencePoints.length === 1) {
                drawPoint(ctx, referencePoints[0], '#FF0000', 'å‚ç…§ç‚¹1');
            }

            // æ¸¬å®šå¯¾è±¡ç·šã‚’æç”»ï¼ˆé’ï¼‰
            if (targetPoints.length >= 2) {
                drawLine(ctx, targetPoints[0], targetPoints[1], '#0000FF', 3, 'æ¸¬å®šç·š');
            } else if (targetPoints.length === 1) {
                drawPoint(ctx, targetPoints[0], '#0000FF', 'æ¸¬å®šç‚¹1');
            }
        }

        // ç·šã‚’æç”»
        function drawLine(ctx, point1, point2, color, width, label) {
            const canvasPoint1 = imageToCanvasCoords(point1.x, point1.y);
            const canvasPoint2 = imageToCanvasCoords(point2.x, point2.y);

            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.moveTo(canvasPoint1.x, canvasPoint1.y);
            ctx.lineTo(canvasPoint2.x, canvasPoint2.y);
            ctx.stroke();

            // ç‚¹ã‚’æç”»
            drawPoint(ctx, point1, color, '');
            drawPoint(ctx, point2, color, '');

            // ãƒ©ãƒ™ãƒ«ã‚’æç”»
            const midX = (canvasPoint1.x + canvasPoint2.x) / 2;
            const midY = (canvasPoint1.y + canvasPoint2.y) / 2;
            
            ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.fillText(label, midX + 10, midY - 10);
        }

        // ç‚¹ã‚’æç”»
        function drawPoint(ctx, point, color, label) {
            const canvasPoint = imageToCanvasCoords(point.x, point.y);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(canvasPoint.x, canvasPoint.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // ç™½ã„ç¸å–ã‚Š
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (label) {
                ctx.fillStyle = color;
                ctx.font = '12px Arial';
                ctx.fillText(label, canvasPoint.x + 10, canvasPoint.y - 10);
            }
        }

        // ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã®å®Ÿè£…
        function setupCaptureZoomControls() {
            const zoomInBtn = document.getElementById('captureZoomInButton');
            const zoomOutBtn = document.getElementById('captureZoomOutButton');
            const zoomResetBtn = document.getElementById('captureZoomResetButton');

            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    captureZoomLevel = Math.min(10, captureZoomLevel * 1.2);
                    redrawCaptureCanvas();
                    updateCaptureDebugInfo();
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    captureZoomLevel = Math.max(0.1, captureZoomLevel * 0.8);
                    redrawCaptureCanvas();
                    updateCaptureDebugInfo();
                });
            }

            if (zoomResetBtn) {
                zoomResetBtn.addEventListener('click', () => {
                    captureZoomLevel = 1.0;
                    captureViewOffsetX = 0;
                    captureViewOffsetY = 0;
                    redrawCaptureCanvas();
                    updateCaptureDebugInfo();
                });
            }
        }        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–°
        function updateCaptureDebugInfo() {
            const debugZoom = document.getElementById('debugZoom');
            const debugOffsetX = document.getElementById('debugOffsetX');
            const debugOffsetY = document.getElementById('debugOffsetY');
            const debugImageSize = document.getElementById('debugImageSize');
            const debugCanvasSize = document.getElementById('debugCanvasSize');
            
            if (debugZoom) debugZoom.textContent = captureZoomLevel.toFixed(2);
            if (debugOffsetX) debugOffsetX.textContent = captureViewOffsetX.toFixed(1);
            if (debugOffsetY) debugOffsetY.textContent = captureViewOffsetY.toFixed(1);
            if (debugImageSize) debugImageSize.textContent = `${captureImageWidth}x${captureImageHeight}`;
            if (debugCanvasSize && captureCanvas) debugCanvasSize.textContent = `${captureCanvas.width}x${captureCanvas.height}`;
        }// ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° (ã‚‚ã—æœªå®šç¾©ã®å ´åˆ)
        if (typeof showUIMessage === 'undefined') {
            function showUIMessage(element, message) {
                console.log("showUIMessage called:", element?.id || 'unknown element', message);
                if (element && typeof element.textContent !== 'undefined') {
                    element.textContent = message;
                } else {
                    console.warn("showUIMessage: Invalid element provided or textContent not available.", element);
                    // Fallback: try to find element by ID if a string was passed
                    if (typeof element === 'string') {
                        const foundElement = document.getElementById(element);
                        if (foundElement) {
                            foundElement.textContent = message;
                        }
                    }
                }
            }
            window.showUIMessage = showUIMessage; // Make it globally accessible
        }
        // 'showMessage' is used in some existing stubs, ensure it's defined or replaced
        if (typeof showMessage === 'undefined') { 
            function showMessage(message) {
                console.log("showMessage called:", message);
                const statusEl = document.getElementById('dimensionStatusText');
                if (statusEl) {
                    showUIMessage(statusEl, message);
                } else {
                    alert(message); // Fallback
                }
                console.log("showMessage:", message);
            }
            window.showMessage = showMessage; // Make it globally accessible
        }


        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–° (å¿…è¦ã«å¿œã˜ã¦èª¿æ•´)
        function updateDebugInfo(e) {
            // This function might need to be adapted for the captureCanvas if debugging is needed there
            // For now, it's related to videoCanvas which is not the primary focus for capture.
            if (!captureCanvas || !window.getCaptureTransformState) return; // Check for capture canvas and state function
            
            const rect = captureCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const { zoom, offsetX, offsetY } = window.getCaptureTransformState();
            const imageCoords = window.toCaptureImageCoords(mouseX, mouseY, zoom, offsetX, offsetY);


            document.getElementById('debugMousePos').textContent = `${mouseX.toFixed(1)}, ${mouseY.toFixed(1)}`;
            if(document.getElementById('debugCanvasPos')) document.getElementById('debugCanvasPos').textContent = `${mouseX.toFixed(1)}, ${mouseY.toFixed(1)}`; // Canvas pos is same as mouse for captureCanvas
            if(document.getElementById('debugImagePos')) document.getElementById('debugImagePos').textContent = imageCoords ? `${imageCoords.x.toFixed(1)}, ${imageCoords.y.toFixed(1)}` : '-';
            
            document.getElementById('debugZoom').textContent = zoom.toFixed(2);
            document.getElementById('debugOffsetX').textContent = offsetX.toFixed(1);
            document.getElementById('debugOffsetY').textContent = offsetY.toFixed(1);
            document.getElementById('debugMeasurementState').textContent = measurementState; // This state needs to be accurately updated
            if(document.getElementById('debugImageSize')) document.getElementById('debugImageSize').textContent = `${captureImageWidth}x${captureImageHeight}`;
            if(document.getElementById('debugCanvasSize')) document.getElementById('debugCanvasSize').textContent = `${captureCanvas.width}x${captureCanvas.height}`;
        }
        if(captureCanvas) captureCanvas.addEventListener('mousemove', updateDebugInfo);        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        function initializeApp() {
            console.log("ï¿½ initializeApp function started");
            
            // åˆæœŸãƒœã‚¿ãƒ³çŠ¶æ…‹
            captureFrameButton.disabled = true;
            startMeasurementButton.disabled = true;
            resetCaptureButton.disabled = true;
            
            console.log("ğŸ”§ Adding event listeners...");
            console.log("ğŸ“Š åˆæœŸçŠ¶æ…‹ç¢ºèª:");
            console.log(`  - Video element: ${videoPlayer ? 'âœ…' : 'âŒ'}`);
            console.log(`  - Capture canvas: ${captureCanvas ? 'âœ…' : 'âŒ'}`);
            console.log(`  - Buttons: Frame=${captureFrameButton ? 'âœ…' : 'âŒ'}, Measurement=${startMeasurementButton ? 'âœ…' : 'âŒ'}, Reset=${resetCaptureButton ? 'âœ…' : 'âŒ'}`);
            console.log(`  - Status elements: Status=${dimensionStatusText ? 'âœ…' : 'âŒ'}, Instruction=${commonInstructionText ? 'âœ…' : 'âŒ'}`);
            
              // å‹•ç”»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
            videoUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                console.log(`ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ: ${file.name} (${file.type}, ${(file.size/1024/1024).toFixed(2)}MB)`);
                showUIMessage(dimensionStatusText, "å‹•ç”»ã‚’å‡¦ç†ä¸­...");
                
                // ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
                captureFrameButton.disabled = true;
                startMeasurementButton.disabled = true;
                resetCaptureButton.disabled = true;
                videoPlayer.style.display = 'none';
                captureImageArea.classList.add('hidden');
                  // ObjectURLä½œæˆ
                const url = URL.createObjectURL(file);
                console.log("ğŸ”— ObjectURLä½œæˆ:", url.substring(0, 50) + "...");
                
                // å‹•ç”»æº–å‚™çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯é–¢æ•°
                let videoReadyHandled = false;
                function checkVideoReady() {
                    if (videoReadyHandled) return;
                    
                    const isReady = videoPlayer.readyState >= 1 && 
                                   videoPlayer.videoWidth > 0 && 
                                   videoPlayer.videoHeight > 0;
                    
                    console.log(`ğŸ“Š å‹•ç”»çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯: ReadyState=${videoPlayer.readyState}, Size=${videoPlayer.videoWidth}x${videoPlayer.videoHeight}`);
                    
                    if (isReady) {
                        videoReadyHandled = true;
                        videoNaturalWidth = videoPlayer.videoWidth;
                        videoNaturalHeight = videoPlayer.videoHeight;
                        
                        console.log('âœ… å‹•ç”»èª­ã¿è¾¼ã¿æˆåŠŸ');
                        videoPlayer.style.display = 'block';
                        captureFrameButton.disabled = false;
                        showUIMessage(dimensionStatusText, "å‹•ç”»ã®æº–å‚™ãŒã§ãã¾ã—ãŸ");
                        showUIMessage(commonInstructionText, "å‹•ç”»ã®å†ç”Ÿã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ“ä½œã—ã¦ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ãŸã„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠã—ã€ã€Œãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚");
                        
                        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆé‡è¤‡å®Ÿè¡Œé˜²æ­¢ï¼‰
                        videoPlayer.removeEventListener('loadedmetadata', checkVideoReady);
                        videoPlayer.removeEventListener('canplay', checkVideoReady);
                        videoPlayer.removeEventListener('loadeddata', checkVideoReady);
                        videoPlayer.removeEventListener('canplaythrough', checkVideoReady);
                    }
                }
                
                // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
                function handleVideoError(e) {
                    let errorMsg = 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
                    if (videoPlayer.error) {
                        const errors = {
                            1: 'MEDIA_ERR_ABORTED - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã£ã¦ä¸­æ­¢ã•ã‚Œã¾ã—ãŸ',
                            2: 'MEDIA_ERR_NETWORK - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
                            3: 'MEDIA_ERR_DECODE - ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
                            4: 'MEDIA_ERR_SRC_NOT_SUPPORTED - ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™'
                        };
                        errorMsg = errors[videoPlayer.error.code] || `ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰: ${videoPlayer.error.code}`;
                    }
                    console.error(`âŒ å‹•ç”»ã‚¨ãƒ©ãƒ¼: ${errorMsg}`);
                    showUIMessage(dimensionStatusText, `ã‚¨ãƒ©ãƒ¼: ${errorMsg}`);
                    showUIMessage(commonInstructionText, "åˆ¥ã®å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è©¦ã™ã‹ã€ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
                }
                
                // ã‚ˆã‚Šå¤šãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒªãƒƒã‚¹ãƒ³
                const videoEvents = ['loadedmetadata', 'canplay', 'loadeddata', 'canplaythrough'];
                videoEvents.forEach(eventName => {
                    videoPlayer.addEventListener(eventName, () => {
                        console.log(`ğŸ¬ Video event: ${eventName}`);
                        checkVideoReady();
                    });
                });
                
                videoPlayer.addEventListener('error', handleVideoError);
                
                // é€²æ—ç¢ºèªã®ãŸã‚ã®è¿½åŠ ã‚¤ãƒ™ãƒ³ãƒˆ
                videoPlayer.addEventListener('loadstart', () => console.log('ğŸ¬ Video loadstart'));
                videoPlayer.addEventListener('progress', () => console.log('ğŸ¬ Video progress'));
                
                // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆå»¶é•·ï¼‰
                setTimeout(() => {
                    if (!videoReadyHandled) {
                        console.warn("âš ï¸ å‹•ç”»èª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (5ç§’)");
                        if (videoPlayer.readyState >= 1 && videoPlayer.videoWidth > 0) {
                            console.log("ğŸ”„ å¼·åˆ¶çš„ã«æº–å‚™å®Œäº†çŠ¶æ…‹ã«ã—ã¾ã™");
                            checkVideoReady();
                        } else {
                            showUIMessage(dimensionStatusText, "å‹•ç”»ã®èª­ã¿è¾¼ã¿ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã„ã¾ã™...");
                        }
                    }
                }, 5000);
                
                // å‹•ç”»ã‚½ãƒ¼ã‚¹è¨­å®š
                videoPlayer.src = url;
                console.log('ğŸ“º å‹•ç”»ã‚½ãƒ¼ã‚¹è¨­å®šå®Œäº†');
            });
            
            // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚­ãƒ£ãƒ—ãƒãƒ£å‡¦ç†ï¼ˆç°¡æ˜“ç‰ˆï¼‰
            captureFrameButton.addEventListener('click', () => {
                if (!videoPlayer.src || videoPlayer.readyState < videoPlayer.HAVE_METADATA) {
                    showUIMessage(dimensionStatusText, "ã‚¨ãƒ©ãƒ¼: å‹•ç”»ãƒ‡ãƒ¼ã‚¿ãŒå®Œå…¨ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
                    return;
                }
                if (videoNaturalWidth === 0 || videoNaturalHeight === 0) {
                    showUIMessage(dimensionStatusText, "ã‚¨ãƒ©ãƒ¼: å‹•ç”»ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å°‘ã€…ãŠå¾…ã¡ãã ã•ã„ã€‚");
                    return;
                }
                
                console.log('ãƒ•ãƒ¬ãƒ¼ãƒ ã‚­ãƒ£ãƒ—ãƒãƒ£é–‹å§‹');
                videoPlayer.pause();
                showUIMessage(dimensionStatusText, "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ä¸­...");
                
                try {
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æç”»
                    captureCanvas.width = videoNaturalWidth;
                    captureCanvas.height = videoNaturalHeight;
                    
                    const ctx = captureCanvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0, videoNaturalWidth, videoNaturalHeight);
                    
                    captureImageWidth = videoNaturalWidth;
                    captureImageHeight = videoNaturalHeight;
                    
                    // ã‚¨ãƒªã‚¢è¡¨ç¤º
                    captureImageArea.classList.remove('hidden');
                    captureZoomControlsContainer.classList.remove('hidden');
                    
                    // ãƒœã‚¿ãƒ³çŠ¶æ…‹æ›´æ–°
                    captureFrameButton.textContent = 'ãƒ•ãƒ¬ãƒ¼ãƒ å†ã‚­ãƒ£ãƒ—ãƒãƒ£';
                    captureFrameButton.disabled = false;
                    startMeasurementButton.disabled = false;
                    resetCaptureButton.disabled = false;
                      console.log('âœ… ãƒ•ãƒ¬ãƒ¼ãƒ ã‚­ãƒ£ãƒ—ãƒãƒ£æˆåŠŸ');
                    showUIMessage(dimensionStatusText, "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¾ã—ãŸã€‚");
                    showUIMessage(commonInstructionText, "ã€Œæ¸¬å®šé–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦å¯¸æ³•æ¸¬å®šã‚’é–‹å§‹ã™ã‚‹ã‹ã€åˆ¥ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦ãã ã•ã„ã€‚");
                    
                    // ã‚­ãƒ£ãƒ—ãƒãƒ£ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
                    capturedImageElement = new Image();
                    capturedImageElement.onload = function() {
                        captureImageWidth = this.width;
                        captureImageHeight = this.height;
                        
                        // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ©Ÿèƒ½ã‚’åˆæœŸåŒ–
                        initCaptureZoomPan();
                        setupCaptureZoomControls();
                        
                        // åˆæœŸæç”»
                        redrawCaptureCanvas();
                        updateCaptureDebugInfo();
                        
                        console.log('ğŸ¯ ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ©Ÿèƒ½ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸ');
                        console.log(`ğŸ“ ç”»åƒã‚µã‚¤ã‚º: ${captureImageWidth}x${captureImageHeight}`);
                    };
                    capturedImageElement.src = captureCanvas.toDataURL();
                    
                } catch (error) {
                    console.error(`ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    showUIMessage(dimensionStatusText, "ãƒ•ãƒ¬ãƒ¼ãƒ ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                }
            });
              // æ¸¬å®šé–‹å§‹å‡¦ç†
            startMeasurementButton.addEventListener('click', () => {
                console.log('æ¸¬å®šé–‹å§‹ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
                
                if (measurementMode === 'none') {
                    // æ¸¬å®šé–‹å§‹
                    measurementMode = 'reference';
                    referencePoints = [];
                    targetPoints = [];
                    
                    // UIè¡¨ç¤º
                    dimensionMeasurementInputs.classList.remove('hidden');
                    resultsArea.classList.remove('hidden');
                    
                    showUIMessage(dimensionStatusText, "å‚ç…§ç·šã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚");
                    showUIMessage(commonInstructionText, "ã¾ãšå‚ç…§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆæ—¢çŸ¥ã®ã‚µã‚¤ã‚ºï¼‰ã®ä¸¡ç«¯ã‚’å·¦ã‚¯ãƒªãƒƒã‚¯ã—ã¦å‚ç…§ç·šã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚");
                    
                    updateMeasurementModeUI();
                    
                } else if (measurementMode === 'completed') {
                    // æ¸¬å®šãƒªã‚»ãƒƒãƒˆ
                    measurementMode = 'none';
                    referencePoints = [];
                    targetPoints = [];
                    
                    // UIè¡¨ç¤º
                    showUIMessage(dimensionStatusText, "æ¸¬å®šã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚");
                    showUIMessage(commonInstructionText, "ã€Œæ¸¬å®šé–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦æ–°ã—ã„æ¸¬å®šã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚");
                    
                    // çµæœã‚¯ãƒªã‚¢
                    document.getElementById('refPixelLengthText').textContent = '-';
                    document.getElementById('targetPixelLengthText').textContent = '-';
                    document.getElementById('scaleText').textContent = '-';
                    document.getElementById('estimatedSizeText').textContent = '-';
                    document.getElementById('refObjectActualSizeInput').value = '';
                    
                    updateMeasurementModeUI();
                    redrawCaptureCanvas();
                }
            });
              // ãƒªã‚»ãƒƒãƒˆå‡¦ç†
            resetCaptureButton.addEventListener('click', () => {
                console.log('ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒªã‚»ãƒƒãƒˆ');
                
                // è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’éš ã™
                captureImageArea.classList.add('hidden');
                captureZoomControlsContainer.classList.add('hidden');
                dimensionMeasurementInputs.classList.add('hidden');
                resultsArea.classList.add('hidden');
                
                // æ¸¬å®šãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
                measurementMode = 'none';
                referencePoints = [];
                targetPoints = [];
                captureZoomLevel = 1.0;
                captureViewOffsetX = 0;
                captureViewOffsetY = 0;
                
                // ãƒœã‚¿ãƒ³çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                captureFrameButton.textContent = 'ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£';
                startMeasurementButton.disabled = true;
                resetCaptureButton.disabled = true;
                
                updateMeasurementModeUI();
                
                showUIMessage(dimensionStatusText, "ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚");
                showUIMessage(commonInstructionText, "æ–°ã—ã„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦ãã ã•ã„ã€‚");
            });
              console.log("âœ… Event listeners added successfully");        }
        
        // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨çŠ¶æ…‹è¨­å®š
        function updateInitialState() {
            showUIMessage(dimensionStatusText, "å¾…æ©Ÿä¸­");
            showUIMessage(commonInstructionText, "å‹•ç”»ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦å¯¸æ³•æ¸¬å®šã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚");
        }
          // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        try {
            console.log("ğŸš€ Starting application initialization...");
            
            // DOMè¦ç´ ã®å†ç¢ºèª
            console.log("ğŸ” DOMè¦ç´ ã®æœ€çµ‚ç¢ºèª:");
            const criticalElements = {
                videoUpload, videoPlayer, captureCanvas, captureFrameButton,
                startMeasurementButton, resetCaptureButton, dimensionStatusText, commonInstructionText
            };
            
            for (const [name, element] of Object.entries(criticalElements)) {
                if (!element) {
                    throw new Error(`é‡è¦ãªè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${name}`);
                }
                console.log(`  âœ… ${name}: OK`);
            }
              initializeApp();
            updateInitialState();
            
            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®åˆæœŸåŒ–
            updateCaptureDebugInfo();
            
            console.log("âœ… Application initialized successfully");
            
        } catch (error) {
            console.error("âŒ Error during application initialization:", error);
            console.error("Stack trace:", error.stack);
            
            // ã‚ˆã‚Šè©³ç´°ãªã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¡¨ç¤º
            const errorDetails = `
åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}

ã“ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š
1. ãƒ–ãƒ©ã‚¦ã‚¶ãŒJavaScriptã‚’æœ‰åŠ¹ã«ã—ã¦ã„ã‚‹
2. ãƒ–ãƒ©ã‚¦ã‚¶ã®é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã§ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¢ºèª
3. ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã¿ã‚‹

æŠ€è¡“è©³ç´°: ${error.stack}`;
            
            alert(errorDetails);
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªã‚¨ãƒ©ãƒ¼è¡¨ç¤º
            document.body.innerHTML += `
                <div style="background: #ffebee; border: 2px solid #f44336; padding: 20px; margin: 20px; border-radius: 4px;">
                    <h2 style="color: #c62828; margin: 0 0 10px 0;">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼</h2>
                    <p style="color: #c62828; margin: 0;"><strong>ã‚¨ãƒ©ãƒ¼:</strong> ${error.message}</p>
                    <p style="color: #666; margin: 10px 0 0 0; font-size: 12px;">ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚å•é¡ŒãŒç¶šãå ´åˆã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã§ã‚¨ãƒ©ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
                </div>`;
        }
    </script>
</body>
</html>
